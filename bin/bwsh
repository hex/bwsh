#!/usr/bin/env bash
# ABOUTME: Shell wrapper for Bitwarden Secrets Manager CLI (bws)
# ABOUTME: Can be sourced for functions or executed as CLI

# Version
BWSH_VERSION="1.2.0"

# Configuration
# Default project ID - set this after creating your project in Bitwarden
# Find your project ID with: bws project list
export BWS_DEFAULT_PROJECT_ID="${BWS_DEFAULT_PROJECT_ID:-}"

# Token file location
BWSH_TOKEN_FILE="${BWSH_TOKEN_FILE:-$HOME/.config/bwsh/token}"
BWSH_PROJECT_FILE="${BWSH_PROJECT_FILE:-$HOME/.config/bwsh/project}"

# Load token from file if not set in environment
_bwsh_load_config() {
    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]] && [[ -f "$BWSH_TOKEN_FILE" ]]; then
        export BWS_ACCESS_TOKEN=$(cat "$BWSH_TOKEN_FILE")
    fi
    if [[ -z "${BWS_DEFAULT_PROJECT_ID:-}" ]] && [[ -f "$BWSH_PROJECT_FILE" ]]; then
        export BWS_DEFAULT_PROJECT_ID=$(cat "$BWSH_PROJECT_FILE")
    fi
}

# Check for required dependencies
_bwsh_check_deps() {
    if ! command -v bws >/dev/null 2>&1; then
        echo "Error: bws (Bitwarden Secrets Manager CLI) not found" >&2
        echo "Install from: https://bitwarden.com/help/secrets-manager-cli/" >&2
        return 1
    fi
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq not found" >&2
        echo "Install with: brew install jq" >&2
        return 1
    fi
}

# Retrieve a secret by key name
# Usage: bwgetkey <key_name> [--project <project_id>]
# Example: bwgetkey ANTHROPIC_API_KEY
bwgetkey() {
    _bwsh_load_config
    local key_name=""
    local project_id=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project_id="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                return 1
                ;;
            *)
                if [[ -z "$key_name" ]]; then
                    key_name="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$key_name" ]]; then
        echo "Usage: bwgetkey <key_name> [--project <project_id>]" >&2
        return 1
    fi

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        echo "Set it with: export BWS_ACCESS_TOKEN='your-token'" >&2
        echo "Or run: bwsh setup" >&2
        return 1
    fi

    # List secrets (optionally filtered by project) and extract value by key name
    local result
    if [[ -n "$project_id" ]]; then
        result=$(bws secret list "$project_id" 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .value" 2>/dev/null)
    else
        result=$(bws secret list 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .value" 2>/dev/null)
    fi

    if [[ -z "$result" ]]; then
        echo "Error: Secret '$key_name' not found" >&2
        return 1
    fi

    echo "$result"
}

# Store a secret
# Usage: bwkey <key_name> [value] [--project <project_id>]
# If value is omitted, prompts securely
# Example: bwkey ANTHROPIC_API_KEY sk-ant-...
bwkey() {
    _bwsh_load_config
    local key_name=""
    local value=""
    local project_id=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project_id="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                return 1
                ;;
            *)
                if [[ -z "$key_name" ]]; then
                    key_name="$1"
                elif [[ -z "$value" ]]; then
                    value="$1"
                fi
                shift
                ;;
        esac
    done

    # Use default project if not specified
    if [[ -z "$project_id" ]]; then
        project_id="${BWS_DEFAULT_PROJECT_ID}"
    fi

    if [[ -z "$key_name" ]]; then
        echo "Usage: bwkey <key_name> [value] [--project <project_id>]" >&2
        return 1
    fi

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        return 1
    fi

    if [[ -z "$project_id" ]]; then
        echo "Error: No project specified and BWS_DEFAULT_PROJECT_ID not set" >&2
        echo "Use --project <id> or run: bwsh setup" >&2
        return 1
    fi

    # Prompt for value if not provided
    if [[ -z "$value" ]]; then
        read -s -p "Enter value for $key_name: " value
        echo
    fi

    # Check if secret already exists (in specified project if given)
    local existing_id
    if [[ -n "$project_id" ]]; then
        existing_id=$(bws secret list "$project_id" 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .id" 2>/dev/null)
    else
        existing_id=$(bws secret list 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .id" 2>/dev/null)
    fi

    if [[ -n "$existing_id" ]]; then
        # Update existing secret
        bws secret edit "$existing_id" --value "$value" >/dev/null
        echo "Updated secret: $key_name"
    else
        # Create new secret
        bws secret create "$key_name" "$value" "$project_id" >/dev/null
        echo "Created secret: $key_name"
    fi
}

# List all secrets (names only, no values)
# Usage: bwkeys
bwkeys() {
    _bwsh_load_config
    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        return 1
    fi

    bws secret list 2>/dev/null | jq -r '.[].key' | sort
}

# Delete a secret by key name
# Usage: bwdelkey <key_name>
bwdelkey() {
    _bwsh_load_config
    local key_name="$1"

    if [[ -z "$key_name" ]]; then
        echo "Usage: bwdelkey <key_name>" >&2
        return 1
    fi

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        return 1
    fi

    local secret_id
    secret_id=$(bws secret list 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .id" 2>/dev/null)

    if [[ -z "$secret_id" ]]; then
        echo "Error: Secret '$key_name' not found" >&2
        return 1
    fi

    bws secret delete "$secret_id" >/dev/null
    echo "Deleted secret: $key_name"
}

# Run a command with secrets injected as environment variables
# Usage: bwrun <command> [args...]
# Example: bwrun npm start
bwrun() {
    _bwsh_load_config
    local project_id="${BWS_DEFAULT_PROJECT_ID}"

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        echo "Run: bwsh setup" >&2
        return 1
    fi

    if [[ -z "$project_id" ]]; then
        echo "Error: BWS_DEFAULT_PROJECT_ID not set" >&2
        echo "Run: bwsh setup" >&2
        return 1
    fi

    if [[ $# -eq 0 ]]; then
        echo "Usage: bwsh run <command> [args...]" >&2
        echo "Example: bwsh run npm start" >&2
        return 1
    fi

    exec bws run --project-id "$project_id" -- "$@"
}

# Export secrets in .env format
# Usage: bwenv export
# Example: bwenv export > .env.local
bwenv() {
    _bwsh_load_config
    local subcmd="${1:-}"

    case "$subcmd" in
        export)
            if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
                echo "Error: BWS_ACCESS_TOKEN not set" >&2
                echo "Run: bwsh setup" >&2
                return 1
            fi
            echo "# Generated by bwsh - do not commit this file" >&2
            bws secret list -o env 2>/dev/null
            ;;
        import)
            shift
            _bwsh_env_import "$@"
            ;;
        *)
            echo "Usage: bwsh env <export|import> [args]" >&2
            echo "" >&2
            echo "Commands:" >&2
            echo "  export              Export secrets as .env format (stdout)" >&2
            echo "  import <file>       Import secrets from .env file" >&2
            echo "" >&2
            echo "Examples:" >&2
            echo "  bwsh env export > .env.local" >&2
            echo "  bwsh env import .env" >&2
            echo "  bwsh env import .env --dry-run" >&2
            return 1
            ;;
    esac
}

# Import secrets from .env file
_bwsh_env_import() {
    local file="${1:-}"
    local dry_run=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                shift
                ;;
            *)
                if [[ -z "$file" ]]; then
                    file="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$file" ]]; then
        echo "Usage: bwsh env import <file> [--dry-run]" >&2
        return 1
    fi

    if [[ ! -f "$file" ]]; then
        echo "Error: File not found: $file" >&2
        return 1
    fi

    local count=0
    local line key value

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        # Parse KEY=VALUE (handle quoted values)
        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"

            # Remove surrounding quotes if present
            if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
                value="${BASH_REMATCH[1]}"
            fi

            if [[ "$dry_run" = true ]]; then
                echo "[dry-run] Would import: $key"
            else
                bwkey "$key" "$value"
            fi
            ((count++))
        fi
    done < "$file"

    if [[ "$dry_run" = true ]]; then
        echo ""
        echo "Dry run complete. Would import $count secret(s)."
    else
        echo ""
        echo "Imported $count secret(s) from $file"
    fi
}

# Interactive setup
_bwsh_setup() {
    echo "bwsh setup"
    echo "=========="
    echo ""

    _bwsh_check_deps || return 1

    mkdir -p "$(dirname "$BWSH_TOKEN_FILE")"

    # Access token
    if [[ -f "$BWSH_TOKEN_FILE" ]]; then
        echo "Access token already configured at $BWSH_TOKEN_FILE"
        read -p "Overwrite? [y/N] " overwrite
        if [[ "$overwrite" =~ ^[Yy]$ ]]; then
            read -s -p "Enter BWS access token: " token
            echo
            echo "$token" > "$BWSH_TOKEN_FILE"
            chmod 600 "$BWSH_TOKEN_FILE"
            echo "Token saved."
        fi
    else
        read -s -p "Enter BWS access token: " token
        echo
        echo "$token" > "$BWSH_TOKEN_FILE"
        chmod 600 "$BWSH_TOKEN_FILE"
        echo "Token saved to $BWSH_TOKEN_FILE"
    fi

    # Load the token we just saved
    export BWS_ACCESS_TOKEN=$(cat "$BWSH_TOKEN_FILE")

    # Project ID
    echo ""
    echo "Available projects:"
    bws project list 2>/dev/null | jq -r '.[] | "  \(.id)  \(.name)"' 2>/dev/null || {
        echo "  (Could not list projects - check your token)"
    }
    echo ""

    if [[ -f "$BWSH_PROJECT_FILE" ]]; then
        echo "Project ID already configured: $(cat "$BWSH_PROJECT_FILE")"
        read -p "Overwrite? [y/N] " overwrite
        if [[ "$overwrite" =~ ^[Yy]$ ]]; then
            read -p "Enter default project ID: " project_id
            echo "$project_id" > "$BWSH_PROJECT_FILE"
            echo "Project ID saved."
        fi
    else
        read -p "Enter default project ID: " project_id
        echo "$project_id" > "$BWSH_PROJECT_FILE"
        echo "Project ID saved to $BWSH_PROJECT_FILE"
    fi

    echo ""
    echo "Setup complete!"
    echo ""
    echo "To enable shell functions, add to your shell rc file:"
    echo "  source $(command -v bwsh 2>/dev/null || echo '~/.local/bin/bwsh')"
}

# Show help
_bwsh_help() {
    cat <<'EOF'
bwsh - Shell wrapper for Bitwarden Secrets Manager

USAGE:
  bwsh <command> [args]     Run as CLI
  source bwsh               Load functions into current shell

COMMANDS:
  get <name> [-p <project>]       Get a secret value
  set <name> [val] [-p <project>] Create or update a secret
  list                            List all secret names
  delete <name>                   Delete a secret
  run <cmd> [args...]       Run command with secrets as env vars
  env export                Export secrets as .env format
  env import <file>         Import secrets from .env file
  setup                     Interactive configuration
  version                   Show version
  help                      Show this help

SHELL FUNCTIONS (when sourced):
  bwgetkey <name> [-p <project>]       Get a secret value
  bwkey <name> [val] [-p <project>]    Create or update a secret
  bwkeys                               List all secret names
  bwdelkey <name>                      Delete a secret
  bwrun <cmd> [args...]     Run command with secrets as env vars
  bwenv export|import       Export/import .env files

ENVIRONMENT VARIABLES:
  BWS_ACCESS_TOKEN          Bitwarden Secrets Manager access token
  BWS_DEFAULT_PROJECT_ID    Default project ID for creating secrets
  BWSH_TOKEN_FILE           Token file path (default: ~/.config/bwsh/token)
  BWSH_PROJECT_FILE         Project file path (default: ~/.config/bwsh/project)

EXAMPLES:
  # CLI mode
  bwsh set API_KEY sk-abc123
  bwsh get API_KEY
  bwsh set DB_PASS secret -p abc123   # Use specific project
  bwsh get DB_PASS -p abc123
  bwsh list
  bwsh delete API_KEY
  bwsh run npm start          # Run with secrets injected
  bwsh env export > .env      # Export to .env file
  bwsh env import .env        # Import from .env file

  # Function mode (after sourcing)
  bwkey API_KEY sk-abc123
  bwgetkey API_KEY
  bwkey DB_PASS secret -p abc123      # Use specific project
  bwkeys
  bwdelkey API_KEY
  bwrun python app.py         # Run with secrets injected
EOF
}

# CLI mode handler
_bwsh_cli() {
    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        get)
            bwgetkey "$@"
            ;;
        set)
            bwkey "$@"
            ;;
        list|ls)
            bwkeys
            ;;
        delete|rm)
            bwdelkey "$@"
            ;;
        run)
            bwrun "$@"
            ;;
        env)
            bwenv "$@"
            ;;
        setup)
            _bwsh_setup
            ;;
        version|-v|--version)
            echo "bwsh $BWSH_VERSION"
            ;;
        help|-h|--help)
            _bwsh_help
            ;;
        "")
            _bwsh_help
            ;;
        *)
            echo "Unknown command: $cmd" >&2
            echo "Run 'bwsh help' for usage" >&2
            return 1
            ;;
    esac
}

# Detect if script is being sourced or executed
# When sourced: just export functions (already defined above)
# When executed: run CLI handler
_bwsh_is_sourced() {
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        # Zsh: $0 contains script path when executed, function name when sourced
        [[ "$ZSH_EVAL_CONTEXT" == *:file:* ]]
    elif [[ -n "${BASH_VERSION:-}" ]]; then
        # Bash: BASH_SOURCE[0] != $0 when sourced
        [[ "${BASH_SOURCE[0]}" != "$0" ]]
    else
        # Fallback: assume executed
        return 1
    fi
}

if ! _bwsh_is_sourced; then
    # Script is being executed directly - enable strict mode
    set -euo pipefail
    _bwsh_cli "$@"
fi
