#!/usr/bin/env bash
# ABOUTME: Shell wrapper for Bitwarden Secrets Manager CLI (bws)
# ABOUTME: Can be sourced for functions or executed as CLI

# Version
BWSH_VERSION="2026.2.2"

# Colors - warm palette (orange/gold)
GREEN='\033[38;2;158;206;106m'
ORANGE='\033[38;2;255;158;100m'
GOLD='\033[38;2;255;199;119m'
COMMENT='\033[38;2;86;95;137m'
NC='\033[0m'

# Configuration
# Default project ID - set this after creating your project in Bitwarden
# Find your project ID with: bws project list
export BWS_DEFAULT_PROJECT_ID="${BWS_DEFAULT_PROJECT_ID:-}"

# Token file location
BWSH_TOKEN_FILE="${BWSH_TOKEN_FILE:-$HOME/.config/bwsh/token}"
BWSH_PROJECT_FILE="${BWSH_PROJECT_FILE:-$HOME/.config/bwsh/project}"

# Cache configuration
BWSH_CACHE_DIR="${BWSH_CACHE_DIR:-$HOME/.cache/bwsh}"
BWSH_CACHE_FILE="$BWSH_CACHE_DIR/secrets.age"
BWSH_AGE_KEY="$HOME/.config/bwsh/age.key"
BWSH_CACHE_TTL="${BWSH_CACHE_TTL:-3600}"  # 1 hour default

# Load token from file if not set in environment
_bwsh_load_config() {
    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]] && [[ -f "$BWSH_TOKEN_FILE" ]]; then
        export BWS_ACCESS_TOKEN=$(cat "$BWSH_TOKEN_FILE")
    fi
    if [[ -z "${BWS_DEFAULT_PROJECT_ID:-}" ]] && [[ -f "$BWSH_PROJECT_FILE" ]]; then
        export BWS_DEFAULT_PROJECT_ID=$(cat "$BWSH_PROJECT_FILE")
    fi
}

# Interactive project selection
# Lists available projects and prompts user to select one
_bwsh_select_project() {
    local projects project_count

    projects=$(bws project list 2>/dev/null | jq -r '.[] | "\(.id)|\(.name)"' 2>/dev/null)

    if [[ -z "$projects" ]]; then
        echo "Error: No projects found (check your token)" >&2
        return 1
    fi

    project_count=$(echo "$projects" | wc -l | tr -d ' ')

    if [[ $project_count -eq 1 ]]; then
        # Auto-select single project
        local selected_id selected_name
        selected_id=$(echo "$projects" | cut -d'|' -f1)
        selected_name=$(echo "$projects" | cut -d'|' -f2)
        echo "Auto-selected project: $selected_name" >&2
        echo "$selected_id"
        return 0
    fi

    # Show numbered list and prompt
    echo "Select a project:" >&2
    local i=1
    while IFS='|' read -r id name; do
        echo "  $i) $name" >&2
        ((i++))
    done <<< "$projects"

    local selection
    read -p "Enter number [1-$project_count]: " selection </dev/tty

    if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt $project_count ]]; then
        echo "Error: Invalid selection" >&2
        return 1
    fi

    echo "$projects" | sed -n "${selection}p" | cut -d'|' -f1
}

# Resolve project name to ID
# Accepts UUID (returned as-is) or name (looked up case-insensitively)
# Usage: _bwsh_resolve_project <name_or_id>
_bwsh_resolve_project() {
    local input="$1"

    # If it looks like a UUID, return as-is
    if [[ "$input" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
        echo "$input"
        return 0
    fi

    # Look up by name (case-insensitive)
    local project_id
    project_id=$(bws project list 2>/dev/null | jq -r ".[] | select(.name | ascii_downcase == \"$(echo "$input" | tr '[:upper:]' '[:lower:]')\") | .id" 2>/dev/null)

    if [[ -z "$project_id" ]]; then
        echo "Error: Project '$input' not found" >&2
        return 1
    fi

    echo "$project_id"
}

# Resolve project ID from explicit flag, config, or interactive selection
# Usage: _bwsh_get_project [explicit_project]
# Accepts project name or UUID for explicit_project
_bwsh_get_project() {
    local explicit_project="$1"

    # Priority 1: Explicit flag (resolve name to ID if needed)
    if [[ -n "$explicit_project" ]]; then
        _bwsh_resolve_project "$explicit_project"
        return $?
    fi

    # Priority 2: Default from config
    if [[ -n "${BWS_DEFAULT_PROJECT_ID:-}" ]]; then
        echo "$BWS_DEFAULT_PROJECT_ID"
        return 0
    fi

    # Priority 3: Interactive selection
    _bwsh_select_project
}

# Check for required dependencies
_bwsh_check_deps() {
    if ! command -v bws >/dev/null 2>&1; then
        echo "Error: bws (Bitwarden Secrets Manager CLI) not found" >&2
        echo "Install from: https://bitwarden.com/help/secrets-manager-cli/" >&2
        return 1
    fi
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq not found" >&2
        echo "Install with: brew install jq" >&2
        return 1
    fi
}

# Check if age is installed (required for caching)
_bwsh_check_age() {
    if ! command -v age >/dev/null 2>&1; then
        echo "Error: age not found (required for encrypted caching)" >&2
        echo "" >&2
        echo "Install with: brew install age" >&2
        echo "More info: https://github.com/FiloSottile/age" >&2
        return 1
    fi
}

# Initialize age key if not exists
_bwsh_init_age_key() {
    if [[ -f "$BWSH_AGE_KEY" ]]; then
        return 0
    fi

    _bwsh_check_age || return 1

    mkdir -p "$(dirname "$BWSH_AGE_KEY")"
    age-keygen -o "$BWSH_AGE_KEY" 2>/dev/null
    chmod 600 "$BWSH_AGE_KEY"
    echo "Created age key: $BWSH_AGE_KEY" >&2
}

# Get age public key from private key file
_bwsh_age_pubkey() {
    grep -o 'age1[a-z0-9]*' "$BWSH_AGE_KEY" 2>/dev/null || \
        age-keygen -y "$BWSH_AGE_KEY" 2>/dev/null
}

# Refresh the encrypted secrets cache
_bwsh_cache_refresh() {
    _bwsh_load_config
    _bwsh_check_age || return 1
    _bwsh_init_age_key || return 1

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        echo "Run: bwsh setup" >&2
        return 1
    fi

    mkdir -p "$BWSH_CACHE_DIR"

    local pubkey
    pubkey=$(_bwsh_age_pubkey) || {
        echo "Error: Could not get age public key" >&2
        return 1
    }

    # Fetch all secrets and convert to shell exports, then encrypt
    local secrets
    secrets=$(bws secret list 2>/dev/null | jq -r '.[] | "export \(.key)=\(.value | @sh)"' 2>/dev/null) || {
        echo "Error: Failed to fetch secrets from bws" >&2
        return 1
    }

    if [[ -z "$secrets" ]]; then
        echo "Warning: No secrets found" >&2
        return 0
    fi

    echo "$secrets" | age -e -r "$pubkey" -o "$BWSH_CACHE_FILE" || {
        echo "Error: Failed to encrypt cache" >&2
        return 1
    }

    chmod 600 "$BWSH_CACHE_FILE"
    echo "Cache refreshed: $(echo "$secrets" | wc -l | tr -d ' ') secrets" >&2
}

# Get cache age in seconds
_bwsh_cache_age() {
    if [[ ! -f "$BWSH_CACHE_FILE" ]]; then
        echo "999999"
        return
    fi

    local file_mtime now
    if [[ "$(uname)" == "Darwin" ]]; then
        file_mtime=$(stat -f%m "$BWSH_CACHE_FILE")
    else
        file_mtime=$(stat -c%Y "$BWSH_CACHE_FILE")
    fi
    now=$(date +%s)
    echo $((now - file_mtime))
}

# Load secrets from encrypted cache
_bwsh_cache_load() {
    if [[ ! -f "$BWSH_CACHE_FILE" ]]; then
        return 1
    fi

    if [[ ! -f "$BWSH_AGE_KEY" ]]; then
        echo "Warning: age key not found, cannot decrypt cache" >&2
        return 1
    fi

    _bwsh_check_age || return 1

    local secrets
    secrets=$(age -d -i "$BWSH_AGE_KEY" "$BWSH_CACHE_FILE" 2>/dev/null) || {
        echo "Warning: Failed to decrypt cache" >&2
        return 1
    }

    eval "$secrets"
}

# Load secrets with caching (main entry point for shell startup)
bwsh_load() {
    local cache_age
    cache_age=$(_bwsh_cache_age)

    if [[ $cache_age -le $BWSH_CACHE_TTL ]] && [[ -f "$BWSH_CACHE_FILE" ]]; then
        # Cache is fresh, load from it
        _bwsh_cache_load && return 0
    fi

    # Cache is stale or missing, try to refresh
    if _bwsh_cache_refresh 2>/dev/null; then
        _bwsh_cache_load
    elif [[ -f "$BWSH_CACHE_FILE" ]]; then
        # Refresh failed but we have stale cache, use it
        echo "Warning: Using stale cache (refresh failed)" >&2
        _bwsh_cache_load
    else
        echo "Error: No cache available and refresh failed" >&2
        return 1
    fi
}

# GitHub repo for updates
BWSH_REPO="hex/bwsh"
BWSH_RAW_URL="https://raw.githubusercontent.com/$BWSH_REPO/main/bin/bwsh"

# Fetch remote version from GitHub
_bwsh_get_remote_version() {
    local remote_script cache_bust
    cache_bust=$(date +%s)
    remote_script=$(curl -fsSL "${BWSH_RAW_URL}?cb=$cache_bust" 2>/dev/null) || return 1
    echo "$remote_script" | grep -m1 'BWSH_VERSION=' | cut -d'"' -f2
}

# Check for updates
_bwsh_update_check() {
    local remote_version
    remote_version=$(_bwsh_get_remote_version) || {
        echo "Error: Could not fetch remote version" >&2
        return 1
    }

    echo "Local:  $BWSH_VERSION"
    echo "Remote: $remote_version"

    if [[ "$BWSH_VERSION" == "$remote_version" ]]; then
        echo "You're up to date."
        return 0
    else
        echo "Update available. Run: bwsh update"
        return 2
    fi
}

# Update bwsh to latest version
_bwsh_update() {
    local check_only=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --check|-c)
                check_only=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ "$check_only" == true ]]; then
        _bwsh_update_check
        return $?
    fi

    local remote_version
    remote_version=$(_bwsh_get_remote_version) || {
        echo "Error: Could not fetch remote version" >&2
        return 1
    }

    if [[ "$BWSH_VERSION" == "$remote_version" ]]; then
        echo -e "${COMMENT}Already up to date${NC} (${GREEN}$BWSH_VERSION${NC})"
        return 0
    fi

    echo ""
    echo -e "   ${COMMENT}Updating${NC} bwsh ${COMMENT}from${NC} ${ORANGE}$BWSH_VERSION${NC} ${COMMENT}→${NC} ${GREEN}$remote_version${NC}"
    echo ""

    # Download installer script
    local install_script cache_bust
    cache_bust=$(date +%s)
    install_script=$(curl -fsSL "https://raw.githubusercontent.com/$BWSH_REPO/main/install.sh?cb=$cache_bust" 2>/dev/null) || {
        echo "Error: Failed to download installer" >&2
        return 1
    }

    # Run the installer
    bash -c "$install_script"

    # Exit to prevent reading old script
    exit 0
}

# Retrieve a secret by key name
# Usage: bwgetkey <key_name> [--project <project_id>]
# Example: bwgetkey ANTHROPIC_API_KEY
bwgetkey() {
    _bwsh_load_config
    local key_name=""
    local project_id=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project_id="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                return 1
                ;;
            *)
                if [[ -z "$key_name" ]]; then
                    key_name="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$key_name" ]]; then
        echo "Usage: bwgetkey <key_name> [--project <project_id>]" >&2
        return 1
    fi

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        echo "Set it with: export BWS_ACCESS_TOKEN='your-token'" >&2
        echo "Or run: bwsh setup" >&2
        return 1
    fi

    # Resolve project name to ID if specified
    local resolved_project=""
    if [[ -n "$project_id" ]]; then
        resolved_project=$(_bwsh_resolve_project "$project_id") || return 1
    fi

    # List secrets (optionally filtered by project) and extract value by key name
    local result
    if [[ -n "$resolved_project" ]]; then
        result=$(bws secret list "$resolved_project" 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .value" 2>/dev/null)
    else
        result=$(bws secret list 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .value" 2>/dev/null)
    fi

    if [[ -z "$result" ]]; then
        echo "Error: Secret '$key_name' not found" >&2
        return 1
    fi

    echo "$result"
}

# Store a secret
# Usage: bwkey <key_name> [value] [--project <project_id>]
# If value is omitted, prompts securely
# Example: bwkey ANTHROPIC_API_KEY sk-ant-...
bwkey() {
    _bwsh_load_config
    local key_name=""
    local value=""
    local project_id=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project_id="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                return 1
                ;;
            *)
                if [[ -z "$key_name" ]]; then
                    key_name="$1"
                elif [[ -z "$value" ]]; then
                    value="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$key_name" ]]; then
        echo "Usage: bwkey <key_name> [value] [--project <project_id>]" >&2
        return 1
    fi

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        return 1
    fi

    # Resolve project: explicit flag > config > interactive selection
    project_id=$(_bwsh_get_project "$project_id") || return 1

    # Prompt for value if not provided
    if [[ -z "$value" ]]; then
        read -s -p "Enter value for $key_name: " value
        echo
    fi

    # Check if secret already exists (in specified project if given)
    local existing_id
    if [[ -n "$project_id" ]]; then
        existing_id=$(bws secret list "$project_id" 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .id" 2>/dev/null)
    else
        existing_id=$(bws secret list 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .id" 2>/dev/null)
    fi

    if [[ -n "$existing_id" ]]; then
        # Update existing secret
        bws secret edit "$existing_id" --value "$value" >/dev/null
        echo "Updated secret: $key_name"
    else
        # Create new secret
        bws secret create "$key_name" "$value" "$project_id" >/dev/null
        echo "Created secret: $key_name"
    fi
}

# List all secrets (names only, no values)
# Usage: bwkeys
bwkeys() {
    _bwsh_load_config
    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        return 1
    fi

    bws secret list 2>/dev/null | jq -r '.[].key' | sort
}

# Delete a secret by key name
# Usage: bwdelkey <key_name>
bwdelkey() {
    _bwsh_load_config
    local key_name="$1"

    if [[ -z "$key_name" ]]; then
        echo "Usage: bwdelkey <key_name>" >&2
        return 1
    fi

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        return 1
    fi

    local secret_id
    secret_id=$(bws secret list 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .id" 2>/dev/null)

    if [[ -z "$secret_id" ]]; then
        echo "Error: Secret '$key_name' not found" >&2
        return 1
    fi

    bws secret delete "$secret_id" >/dev/null
    echo "Deleted secret: $key_name"
}

# Run a command with secrets injected as environment variables
# Usage: bwrun [--project <project_id>] <command> [args...]
# Example: bwrun npm start
bwrun() {
    _bwsh_load_config
    local project_id=""
    local -a cmd_args=()

    # Parse arguments - collect command args after first non-flag
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project_id="$2"
                shift 2
                ;;
            -*)
                # Unknown flag - might be for the command, pass it through
                cmd_args+=("$1")
                shift
                ;;
            *)
                # First non-flag starts the command
                cmd_args+=("$@")
                break
                ;;
        esac
    done

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        echo "Run: bwsh setup" >&2
        return 1
    fi

    if [[ ${#cmd_args[@]} -eq 0 ]]; then
        echo "Usage: bwsh run [--project <project_id>] <command> [args...]" >&2
        echo "Example: bwsh run npm start" >&2
        echo "         bwsh run -p <project_id> npm start" >&2
        return 1
    fi

    # Resolve project: explicit flag > config > interactive selection
    project_id=$(_bwsh_get_project "$project_id") || return 1

    exec bws run --project-id "$project_id" -- "${cmd_args[@]}"
}

# Export secrets in .env format
# Usage: bwenv export
# Example: bwenv export > .env.local
bwenv() {
    _bwsh_load_config
    local subcmd="${1:-}"

    case "$subcmd" in
        export)
            if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
                echo "Error: BWS_ACCESS_TOKEN not set" >&2
                echo "Run: bwsh setup" >&2
                return 1
            fi
            echo "# Generated by bwsh - do not commit this file" >&2
            bws secret list -o env 2>/dev/null
            ;;
        import)
            shift
            _bwsh_env_import "$@"
            ;;
        *)
            echo "Usage: bwsh env <export|import> [args]" >&2
            echo "" >&2
            echo "Commands:" >&2
            echo "  export                       Export secrets as .env format (stdout)" >&2
            echo "  import <file> [-p <project>] Import secrets from .env file" >&2
            echo "" >&2
            echo "Examples:" >&2
            echo "  bwsh env export > .env.local" >&2
            echo "  bwsh env import .env" >&2
            echo "  bwsh env import .env -p <project_id>" >&2
            echo "  bwsh env import .env --dry-run" >&2
            return 1
            ;;
    esac
}

# Import secrets from .env file
_bwsh_env_import() {
    local file=""
    local project_id=""
    local dry_run=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project_id="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            *)
                if [[ -z "$file" ]]; then
                    file="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$file" ]]; then
        echo "Usage: bwsh env import <file> [--project <project_id>] [--dry-run]" >&2
        return 1
    fi

    if [[ ! -f "$file" ]]; then
        echo "Error: File not found: $file" >&2
        return 1
    fi

    # Resolve project once for all imports (avoid prompting per-secret)
    if [[ "$dry_run" != true ]]; then
        project_id=$(_bwsh_get_project "$project_id") || return 1
    fi

    local count=0
    local line key value

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        # Parse KEY=VALUE (handle quoted values)
        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"

            # Remove surrounding quotes if present
            if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
                value="${BASH_REMATCH[1]}"
            fi

            if [[ "$dry_run" = true ]]; then
                echo "[dry-run] Would import: $key"
            else
                bwkey "$key" "$value" --project "$project_id"
            fi
            ((count++))
        fi
    done < "$file"

    if [[ "$dry_run" = true ]]; then
        echo ""
        echo "Dry run complete. Would import $count secret(s)."
    else
        echo ""
        echo "Imported $count secret(s) from $file"
    fi
}

# Interactive setup
_bwsh_setup() {
    echo "bwsh setup"
    echo "=========="
    echo ""

    _bwsh_check_deps || return 1

    mkdir -p "$(dirname "$BWSH_TOKEN_FILE")"

    # Access token
    if [[ -f "$BWSH_TOKEN_FILE" ]]; then
        echo "Access token already configured at $BWSH_TOKEN_FILE"
        read -p "Overwrite? [y/N] " overwrite
        if [[ "$overwrite" =~ ^[Yy]$ ]]; then
            read -s -p "Enter BWS access token: " token
            echo
            echo "$token" > "$BWSH_TOKEN_FILE"
            chmod 600 "$BWSH_TOKEN_FILE"
            echo "Token saved."
        fi
    else
        read -s -p "Enter BWS access token: " token
        echo
        echo "$token" > "$BWSH_TOKEN_FILE"
        chmod 600 "$BWSH_TOKEN_FILE"
        echo "Token saved to $BWSH_TOKEN_FILE"
    fi

    # Load the token we just saved
    export BWS_ACCESS_TOKEN=$(cat "$BWSH_TOKEN_FILE")

    # Project ID (optional)
    echo ""
    echo "Available projects:"
    bws project list 2>/dev/null | jq -r '.[] | "  \(.id)  \(.name)"' 2>/dev/null || {
        echo "  (Could not list projects - check your token)"
    }
    echo ""
    echo "(Optional) Set a default project, or leave blank to select per-operation."

    if [[ -f "$BWSH_PROJECT_FILE" ]]; then
        echo "Project ID already configured: $(cat "$BWSH_PROJECT_FILE")"
        read -p "Overwrite? [y/N/clear] " overwrite
        if [[ "$overwrite" =~ ^[Yy]$ ]]; then
            read -p "Enter default project ID (or blank to skip): " project_id
            if [[ -n "$project_id" ]]; then
                echo "$project_id" > "$BWSH_PROJECT_FILE"
                echo "Project ID saved."
            fi
        elif [[ "$overwrite" == "clear" ]]; then
            rm -f "$BWSH_PROJECT_FILE"
            echo "Default project cleared. You'll be prompted to select a project per-operation."
        fi
    else
        read -p "Enter default project ID (or blank to skip): " project_id
        if [[ -n "$project_id" ]]; then
            echo "$project_id" > "$BWSH_PROJECT_FILE"
            echo "Project ID saved to $BWSH_PROJECT_FILE"
        else
            echo "No default project set. You'll be prompted to select a project per-operation."
        fi
    fi

    echo ""
    echo "Setup complete!"
    echo ""
    echo "To enable shell functions, add to your shell rc file:"
    echo "  source $(command -v bwsh 2>/dev/null || echo '~/.local/bin/bwsh')"
}

# Cache management command
_bwsh_cache() {
    local subcmd="${1:-}"
    shift || true

    case "$subcmd" in
        refresh)
            _bwsh_cache_refresh
            ;;
        clear)
            if [[ -f "$BWSH_CACHE_FILE" ]]; then
                rm -f "$BWSH_CACHE_FILE"
                echo "Cache cleared"
            else
                echo "No cache to clear"
            fi
            ;;
        status)
            echo "Cache file: $BWSH_CACHE_FILE"
            echo "Cache TTL: ${BWSH_CACHE_TTL}s"
            echo "Age key: $BWSH_AGE_KEY"
            echo ""

            if [[ -f "$BWSH_CACHE_FILE" ]]; then
                local age
                age=$(_bwsh_cache_age)
                local size
                size=$(ls -lh "$BWSH_CACHE_FILE" | awk '{print $5}')
                echo "Status: cached"
                echo "Age: ${age}s (TTL: ${BWSH_CACHE_TTL}s)"
                echo "Size: $size"
                if [[ $age -gt $BWSH_CACHE_TTL ]]; then
                    echo "State: stale (will refresh on next load)"
                else
                    echo "State: fresh"
                fi
            else
                echo "Status: no cache"
            fi

            if [[ -f "$BWSH_AGE_KEY" ]]; then
                echo ""
                echo "Age key: present"
            else
                echo ""
                echo "Age key: not initialized"
            fi

            if command -v age >/dev/null 2>&1; then
                echo "Age: installed ($(age --version 2>/dev/null || echo 'unknown version'))"
            else
                echo "Age: NOT INSTALLED"
                echo "  Install with: brew install age"
                echo "  More info: https://github.com/FiloSottile/age"
            fi
            ;;
        *)
            echo "Usage: bwsh cache <refresh|clear|status>" >&2
            echo "" >&2
            echo "Commands:" >&2
            echo "  refresh   Fetch secrets from bws and update encrypted cache" >&2
            echo "  clear     Delete the local cache" >&2
            echo "  status    Show cache information" >&2
            return 1
            ;;
    esac
}

# Show help
_bwsh_help() {
    cat <<'EOF'
bwsh - Shell wrapper for Bitwarden Secrets Manager

USAGE:
  bwsh <command> [args]     Run as CLI
  source bwsh               Load functions into current shell

COMMANDS:
  get <name> [-p <project>]           Get a secret value
  set <name> [val] [-p <project>]     Create or update a secret
  list                                List all secret names
  delete <name>                       Delete a secret
  run [-p <project>] <cmd> [args...]  Run command with secrets as env vars
  env export                          Export secrets as .env format
  env import <file> [-p <project>]    Import secrets from .env file
  cache refresh                       Refresh encrypted local cache
  cache clear                         Delete local cache
  cache status                        Show cache information
  load                                Load secrets from cache (for shell startup)
  setup                               Interactive configuration
  update [--check]                    Update to latest version
  uninstall [--force]                 Remove bwsh (--force removes config too)
  version                             Show version
  help                                Show this help

PROJECT RESOLUTION:
  Commands that need a project use this priority:
  1. Explicit -p/--project flag
  2. Default project from config (BWS_DEFAULT_PROJECT_ID)
  3. Interactive selection (prompts you to choose)

SHELL FUNCTIONS (when sourced):
  bwsh_load                               Load all secrets from encrypted cache
  bwgetkey <name> [-p <project>]          Get a secret value
  bwkey <name> [val] [-p <project>]       Create or update a secret
  bwkeys                                  List all secret names
  bwdelkey <name>                         Delete a secret
  bwrun [-p <project>] <cmd> [args...]    Run command with secrets as env vars
  bwenv export|import                     Export/import .env files

ENVIRONMENT VARIABLES:
  BWS_ACCESS_TOKEN          Bitwarden Secrets Manager access token
  BWS_DEFAULT_PROJECT_ID    Default project ID for creating secrets
  BWSH_TOKEN_FILE           Token file path (default: ~/.config/bwsh/token)
  BWSH_PROJECT_FILE         Project file path (default: ~/.config/bwsh/project)
  BWSH_CACHE_DIR            Cache directory (default: ~/.cache/bwsh)
  BWSH_CACHE_TTL            Cache TTL in seconds (default: 3600)

EXAMPLES:
  # CLI mode
  bwsh set API_KEY sk-abc123
  bwsh get API_KEY
  bwsh set DB_PASS secret -p abc123   # Use specific project
  bwsh get DB_PASS -p abc123
  bwsh list
  bwsh delete API_KEY
  bwsh run npm start                  # Run with secrets injected
  bwsh run -p abc123 npm start        # Run with specific project
  bwsh env export > .env              # Export to .env file
  bwsh env import .env                # Import from .env file
  bwsh env import .env -p abc123      # Import to specific project
  bwsh cache status                   # Check cache state
  bwsh cache refresh                  # Force refresh cache

  # Function mode (after sourcing)
  bwkey API_KEY sk-abc123
  bwgetkey API_KEY
  bwkey DB_PASS secret -p abc123      # Use specific project
  bwkeys
  bwdelkey API_KEY
  bwrun python app.py                 # Run with secrets injected
  bwrun -p abc123 python app.py       # Run with specific project
EOF
}

# Uninstall bwsh
_bwsh_uninstall() {
    local force=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f)
                force=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    echo ""
    echo -e "   ${COMMENT}Uninstalling${NC} bwsh"
    echo ""

    local files_to_remove=(
        "$HOME/.local/bin/bwsh"
        "$HOME/.bash_completion.d/bwsh.bash"
        "$HOME/.zsh/completions/_bwsh"
    )

    local config_files=(
        "$HOME/.config/bwsh/token"
        "$HOME/.config/bwsh/project"
        "$HOME/.config/bwsh/age.key"
        "$HOME/.cache/bwsh/secrets.age"
    )

    # Remove main files
    for file in "${files_to_remove[@]}"; do
        if [[ -f "$file" ]]; then
            rm -f "$file"
            echo -e "   ${COMMENT}Removed${NC} $file"
        fi
    done

    # Handle config/cache
    if [[ "$force" == true ]]; then
        for file in "${config_files[@]}"; do
            if [[ -f "$file" ]]; then
                rm -f "$file"
                echo -e "   ${COMMENT}Removed${NC} $file"
            fi
        done
        rmdir "$HOME/.config/bwsh" 2>/dev/null && echo -e "   ${COMMENT}Removed${NC} $HOME/.config/bwsh"
        rmdir "$HOME/.cache/bwsh" 2>/dev/null && echo -e "   ${COMMENT}Removed${NC} $HOME/.cache/bwsh"
    else
        if [[ -d "$HOME/.config/bwsh" ]] || [[ -d "$HOME/.cache/bwsh" ]]; then
            echo ""
            echo -e "   ${COMMENT}Kept config/cache (use --force to remove):${NC}"
            [[ -d "$HOME/.config/bwsh" ]] && echo "     ~/.config/bwsh/"
            [[ -d "$HOME/.cache/bwsh" ]] && echo "     ~/.cache/bwsh/"
        fi
    fi

    echo ""
    echo -e "   ${GREEN}✓${NC} Uninstall complete"
    echo ""
    echo -e "   ${COMMENT}Remove these lines from your shell rc file:${NC}"
    echo "     source ~/.local/bin/bwsh"
    echo "     bwsh_load"
    echo ""
}

# CLI mode handler
_bwsh_cli() {
    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        get)
            bwgetkey "$@"
            ;;
        set)
            bwkey "$@"
            ;;
        list|ls)
            bwkeys
            ;;
        delete|rm)
            bwdelkey "$@"
            ;;
        run)
            bwrun "$@"
            ;;
        env)
            bwenv "$@"
            ;;
        cache)
            _bwsh_cache "$@"
            ;;
        load)
            bwsh_load
            ;;
        setup)
            _bwsh_setup
            ;;
        update)
            _bwsh_update "$@"
            ;;
        uninstall)
            _bwsh_uninstall "$@"
            ;;
        version|-v|--version)
            echo "bwsh $BWSH_VERSION"
            ;;
        help|-h|--help)
            _bwsh_help
            ;;
        "")
            _bwsh_help
            ;;
        *)
            echo "Unknown command: $cmd" >&2
            echo "Run 'bwsh help' for usage" >&2
            return 1
            ;;
    esac
}

# Detect if script is being sourced or executed
# When sourced: just export functions (already defined above)
# When executed: run CLI handler
_bwsh_is_sourced() {
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        # Zsh: $0 contains script path when executed, function name when sourced
        [[ "$ZSH_EVAL_CONTEXT" == *:file:* ]]
    elif [[ -n "${BASH_VERSION:-}" ]]; then
        # Bash: BASH_SOURCE[0] != $0 when sourced
        [[ "${BASH_SOURCE[0]}" != "$0" ]]
    else
        # Fallback: assume executed
        return 1
    fi
}

if ! _bwsh_is_sourced; then
    # Script is being executed directly - enable strict mode
    set -euo pipefail
    _bwsh_cli "$@"
fi
