#!/usr/bin/env bash
# ABOUTME: Shell wrapper for Bitwarden Secrets Manager CLI (bws)
# ABOUTME: Can be sourced for functions or executed as CLI

# Version
BWSH_VERSION="2026.1.1"

# Configuration
# Default project ID - set this after creating your project in Bitwarden
# Find your project ID with: bws project list
export BWS_DEFAULT_PROJECT_ID="${BWS_DEFAULT_PROJECT_ID:-}"

# Token file location
BWSH_TOKEN_FILE="${BWSH_TOKEN_FILE:-$HOME/.config/bwsh/token}"
BWSH_PROJECT_FILE="${BWSH_PROJECT_FILE:-$HOME/.config/bwsh/project}"

# Load token from file if not set in environment
_bwsh_load_config() {
    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]] && [[ -f "$BWSH_TOKEN_FILE" ]]; then
        export BWS_ACCESS_TOKEN=$(cat "$BWSH_TOKEN_FILE")
    fi
    if [[ -z "${BWS_DEFAULT_PROJECT_ID:-}" ]] && [[ -f "$BWSH_PROJECT_FILE" ]]; then
        export BWS_DEFAULT_PROJECT_ID=$(cat "$BWSH_PROJECT_FILE")
    fi
}

# Interactive project selection
# Lists available projects and prompts user to select one
_bwsh_select_project() {
    local projects project_count

    projects=$(bws project list 2>/dev/null | jq -r '.[] | "\(.id)|\(.name)"' 2>/dev/null)

    if [[ -z "$projects" ]]; then
        echo "Error: No projects found (check your token)" >&2
        return 1
    fi

    project_count=$(echo "$projects" | wc -l | tr -d ' ')

    if [[ $project_count -eq 1 ]]; then
        # Auto-select single project
        local selected_id selected_name
        selected_id=$(echo "$projects" | cut -d'|' -f1)
        selected_name=$(echo "$projects" | cut -d'|' -f2)
        echo "Auto-selected project: $selected_name" >&2
        echo "$selected_id"
        return 0
    fi

    # Show numbered list and prompt
    echo "Select a project:" >&2
    local i=1
    while IFS='|' read -r id name; do
        echo "  $i) $name" >&2
        ((i++))
    done <<< "$projects"

    local selection
    read -p "Enter number [1-$project_count]: " selection </dev/tty

    if [[ ! "$selection" =~ ^[0-9]+$ ]] || [[ $selection -lt 1 ]] || [[ $selection -gt $project_count ]]; then
        echo "Error: Invalid selection" >&2
        return 1
    fi

    echo "$projects" | sed -n "${selection}p" | cut -d'|' -f1
}

# Resolve project name to ID
# Accepts UUID (returned as-is) or name (looked up case-insensitively)
# Usage: _bwsh_resolve_project <name_or_id>
_bwsh_resolve_project() {
    local input="$1"

    # If it looks like a UUID, return as-is
    if [[ "$input" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
        echo "$input"
        return 0
    fi

    # Look up by name (case-insensitive)
    local project_id
    project_id=$(bws project list 2>/dev/null | jq -r ".[] | select(.name | ascii_downcase == \"$(echo "$input" | tr '[:upper:]' '[:lower:]')\") | .id" 2>/dev/null)

    if [[ -z "$project_id" ]]; then
        echo "Error: Project '$input' not found" >&2
        return 1
    fi

    echo "$project_id"
}

# Resolve project ID from explicit flag, config, or interactive selection
# Usage: _bwsh_get_project [explicit_project]
# Accepts project name or UUID for explicit_project
_bwsh_get_project() {
    local explicit_project="$1"

    # Priority 1: Explicit flag (resolve name to ID if needed)
    if [[ -n "$explicit_project" ]]; then
        _bwsh_resolve_project "$explicit_project"
        return $?
    fi

    # Priority 2: Default from config
    if [[ -n "${BWS_DEFAULT_PROJECT_ID:-}" ]]; then
        echo "$BWS_DEFAULT_PROJECT_ID"
        return 0
    fi

    # Priority 3: Interactive selection
    _bwsh_select_project
}

# Check for required dependencies
_bwsh_check_deps() {
    if ! command -v bws >/dev/null 2>&1; then
        echo "Error: bws (Bitwarden Secrets Manager CLI) not found" >&2
        echo "Install from: https://bitwarden.com/help/secrets-manager-cli/" >&2
        return 1
    fi
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq not found" >&2
        echo "Install with: brew install jq" >&2
        return 1
    fi
}

# GitHub repo for updates
BWSH_REPO="hex/bwsh"
BWSH_RAW_URL="https://raw.githubusercontent.com/$BWSH_REPO/main/bin/bwsh"

# Check for updates
_bwsh_update_check() {
    local remote_version
    remote_version=$(curl -fsSL "$BWSH_RAW_URL" 2>/dev/null | grep -m1 'BWSH_VERSION=' | cut -d'"' -f2)

    if [[ -z "$remote_version" ]]; then
        echo "Error: Could not fetch remote version" >&2
        return 1
    fi

    echo "Local:  $BWSH_VERSION"
    echo "Remote: $remote_version"

    if [[ "$BWSH_VERSION" == "$remote_version" ]]; then
        echo "You're up to date."
        return 0
    else
        echo "Update available. Run: bwsh update"
        return 2
    fi
}

# Update bwsh to latest version
_bwsh_update() {
    local check_only=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --check|-c)
                check_only=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ "$check_only" == true ]]; then
        _bwsh_update_check
        return $?
    fi

    echo "Checking for updates..."
    local remote_version
    remote_version=$(curl -fsSL "$BWSH_RAW_URL" 2>/dev/null | grep -m1 'BWSH_VERSION=' | cut -d'"' -f2)

    if [[ -z "$remote_version" ]]; then
        echo "Error: Could not fetch remote version" >&2
        return 1
    fi

    if [[ "$BWSH_VERSION" == "$remote_version" ]]; then
        echo "Already at latest version ($BWSH_VERSION)"
        return 0
    fi

    echo "Updating from $BWSH_VERSION to $remote_version..."

    # Download and run installer
    local installer_url="https://raw.githubusercontent.com/$BWSH_REPO/main/install.sh"
    if curl -fsSL "$installer_url" | bash; then
        echo "Update complete. Restart your shell or run: source $(command -v bwsh)"
    else
        echo "Error: Update failed" >&2
        return 1
    fi
}

# Retrieve a secret by key name
# Usage: bwgetkey <key_name> [--project <project_id>]
# Example: bwgetkey ANTHROPIC_API_KEY
bwgetkey() {
    _bwsh_load_config
    local key_name=""
    local project_id=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project_id="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                return 1
                ;;
            *)
                if [[ -z "$key_name" ]]; then
                    key_name="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$key_name" ]]; then
        echo "Usage: bwgetkey <key_name> [--project <project_id>]" >&2
        return 1
    fi

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        echo "Set it with: export BWS_ACCESS_TOKEN='your-token'" >&2
        echo "Or run: bwsh setup" >&2
        return 1
    fi

    # Resolve project name to ID if specified
    local resolved_project=""
    if [[ -n "$project_id" ]]; then
        resolved_project=$(_bwsh_resolve_project "$project_id") || return 1
    fi

    # List secrets (optionally filtered by project) and extract value by key name
    local result
    if [[ -n "$resolved_project" ]]; then
        result=$(bws secret list "$resolved_project" 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .value" 2>/dev/null)
    else
        result=$(bws secret list 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .value" 2>/dev/null)
    fi

    if [[ -z "$result" ]]; then
        echo "Error: Secret '$key_name' not found" >&2
        return 1
    fi

    echo "$result"
}

# Store a secret
# Usage: bwkey <key_name> [value] [--project <project_id>]
# If value is omitted, prompts securely
# Example: bwkey ANTHROPIC_API_KEY sk-ant-...
bwkey() {
    _bwsh_load_config
    local key_name=""
    local value=""
    local project_id=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project_id="$2"
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                return 1
                ;;
            *)
                if [[ -z "$key_name" ]]; then
                    key_name="$1"
                elif [[ -z "$value" ]]; then
                    value="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$key_name" ]]; then
        echo "Usage: bwkey <key_name> [value] [--project <project_id>]" >&2
        return 1
    fi

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        return 1
    fi

    # Resolve project: explicit flag > config > interactive selection
    project_id=$(_bwsh_get_project "$project_id") || return 1

    # Prompt for value if not provided
    if [[ -z "$value" ]]; then
        read -s -p "Enter value for $key_name: " value
        echo
    fi

    # Check if secret already exists (in specified project if given)
    local existing_id
    if [[ -n "$project_id" ]]; then
        existing_id=$(bws secret list "$project_id" 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .id" 2>/dev/null)
    else
        existing_id=$(bws secret list 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .id" 2>/dev/null)
    fi

    if [[ -n "$existing_id" ]]; then
        # Update existing secret
        bws secret edit "$existing_id" --value "$value" >/dev/null
        echo "Updated secret: $key_name"
    else
        # Create new secret
        bws secret create "$key_name" "$value" "$project_id" >/dev/null
        echo "Created secret: $key_name"
    fi
}

# List all secrets (names only, no values)
# Usage: bwkeys
bwkeys() {
    _bwsh_load_config
    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        return 1
    fi

    bws secret list 2>/dev/null | jq -r '.[].key' | sort
}

# Delete a secret by key name
# Usage: bwdelkey <key_name>
bwdelkey() {
    _bwsh_load_config
    local key_name="$1"

    if [[ -z "$key_name" ]]; then
        echo "Usage: bwdelkey <key_name>" >&2
        return 1
    fi

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        return 1
    fi

    local secret_id
    secret_id=$(bws secret list 2>/dev/null | jq -r ".[] | select(.key==\"$key_name\") | .id" 2>/dev/null)

    if [[ -z "$secret_id" ]]; then
        echo "Error: Secret '$key_name' not found" >&2
        return 1
    fi

    bws secret delete "$secret_id" >/dev/null
    echo "Deleted secret: $key_name"
}

# Run a command with secrets injected as environment variables
# Usage: bwrun [--project <project_id>] <command> [args...]
# Example: bwrun npm start
bwrun() {
    _bwsh_load_config
    local project_id=""
    local -a cmd_args=()

    # Parse arguments - collect command args after first non-flag
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project_id="$2"
                shift 2
                ;;
            -*)
                # Unknown flag - might be for the command, pass it through
                cmd_args+=("$1")
                shift
                ;;
            *)
                # First non-flag starts the command
                cmd_args+=("$@")
                break
                ;;
        esac
    done

    if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
        echo "Error: BWS_ACCESS_TOKEN not set" >&2
        echo "Run: bwsh setup" >&2
        return 1
    fi

    if [[ ${#cmd_args[@]} -eq 0 ]]; then
        echo "Usage: bwsh run [--project <project_id>] <command> [args...]" >&2
        echo "Example: bwsh run npm start" >&2
        echo "         bwsh run -p <project_id> npm start" >&2
        return 1
    fi

    # Resolve project: explicit flag > config > interactive selection
    project_id=$(_bwsh_get_project "$project_id") || return 1

    exec bws run --project-id "$project_id" -- "${cmd_args[@]}"
}

# Export secrets in .env format
# Usage: bwenv export
# Example: bwenv export > .env.local
bwenv() {
    _bwsh_load_config
    local subcmd="${1:-}"

    case "$subcmd" in
        export)
            if [[ -z "${BWS_ACCESS_TOKEN:-}" ]]; then
                echo "Error: BWS_ACCESS_TOKEN not set" >&2
                echo "Run: bwsh setup" >&2
                return 1
            fi
            echo "# Generated by bwsh - do not commit this file" >&2
            bws secret list -o env 2>/dev/null
            ;;
        import)
            shift
            _bwsh_env_import "$@"
            ;;
        *)
            echo "Usage: bwsh env <export|import> [args]" >&2
            echo "" >&2
            echo "Commands:" >&2
            echo "  export                       Export secrets as .env format (stdout)" >&2
            echo "  import <file> [-p <project>] Import secrets from .env file" >&2
            echo "" >&2
            echo "Examples:" >&2
            echo "  bwsh env export > .env.local" >&2
            echo "  bwsh env import .env" >&2
            echo "  bwsh env import .env -p <project_id>" >&2
            echo "  bwsh env import .env --dry-run" >&2
            return 1
            ;;
    esac
}

# Import secrets from .env file
_bwsh_env_import() {
    local file=""
    local project_id=""
    local dry_run=false

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --project|-p)
                project_id="$2"
                shift 2
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            *)
                if [[ -z "$file" ]]; then
                    file="$1"
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$file" ]]; then
        echo "Usage: bwsh env import <file> [--project <project_id>] [--dry-run]" >&2
        return 1
    fi

    if [[ ! -f "$file" ]]; then
        echo "Error: File not found: $file" >&2
        return 1
    fi

    # Resolve project once for all imports (avoid prompting per-secret)
    if [[ "$dry_run" != true ]]; then
        project_id=$(_bwsh_get_project "$project_id") || return 1
    fi

    local count=0
    local line key value

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue

        # Parse KEY=VALUE (handle quoted values)
        if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"

            # Remove surrounding quotes if present
            if [[ "$value" =~ ^\"(.*)\"$ ]] || [[ "$value" =~ ^\'(.*)\'$ ]]; then
                value="${BASH_REMATCH[1]}"
            fi

            if [[ "$dry_run" = true ]]; then
                echo "[dry-run] Would import: $key"
            else
                bwkey "$key" "$value" --project "$project_id"
            fi
            ((count++))
        fi
    done < "$file"

    if [[ "$dry_run" = true ]]; then
        echo ""
        echo "Dry run complete. Would import $count secret(s)."
    else
        echo ""
        echo "Imported $count secret(s) from $file"
    fi
}

# Interactive setup
_bwsh_setup() {
    echo "bwsh setup"
    echo "=========="
    echo ""

    _bwsh_check_deps || return 1

    mkdir -p "$(dirname "$BWSH_TOKEN_FILE")"

    # Access token
    if [[ -f "$BWSH_TOKEN_FILE" ]]; then
        echo "Access token already configured at $BWSH_TOKEN_FILE"
        read -p "Overwrite? [y/N] " overwrite
        if [[ "$overwrite" =~ ^[Yy]$ ]]; then
            read -s -p "Enter BWS access token: " token
            echo
            echo "$token" > "$BWSH_TOKEN_FILE"
            chmod 600 "$BWSH_TOKEN_FILE"
            echo "Token saved."
        fi
    else
        read -s -p "Enter BWS access token: " token
        echo
        echo "$token" > "$BWSH_TOKEN_FILE"
        chmod 600 "$BWSH_TOKEN_FILE"
        echo "Token saved to $BWSH_TOKEN_FILE"
    fi

    # Load the token we just saved
    export BWS_ACCESS_TOKEN=$(cat "$BWSH_TOKEN_FILE")

    # Project ID (optional)
    echo ""
    echo "Available projects:"
    bws project list 2>/dev/null | jq -r '.[] | "  \(.id)  \(.name)"' 2>/dev/null || {
        echo "  (Could not list projects - check your token)"
    }
    echo ""
    echo "(Optional) Set a default project, or leave blank to select per-operation."

    if [[ -f "$BWSH_PROJECT_FILE" ]]; then
        echo "Project ID already configured: $(cat "$BWSH_PROJECT_FILE")"
        read -p "Overwrite? [y/N/clear] " overwrite
        if [[ "$overwrite" =~ ^[Yy]$ ]]; then
            read -p "Enter default project ID (or blank to skip): " project_id
            if [[ -n "$project_id" ]]; then
                echo "$project_id" > "$BWSH_PROJECT_FILE"
                echo "Project ID saved."
            fi
        elif [[ "$overwrite" == "clear" ]]; then
            rm -f "$BWSH_PROJECT_FILE"
            echo "Default project cleared. You'll be prompted to select a project per-operation."
        fi
    else
        read -p "Enter default project ID (or blank to skip): " project_id
        if [[ -n "$project_id" ]]; then
            echo "$project_id" > "$BWSH_PROJECT_FILE"
            echo "Project ID saved to $BWSH_PROJECT_FILE"
        else
            echo "No default project set. You'll be prompted to select a project per-operation."
        fi
    fi

    echo ""
    echo "Setup complete!"
    echo ""
    echo "To enable shell functions, add to your shell rc file:"
    echo "  source $(command -v bwsh 2>/dev/null || echo '~/.local/bin/bwsh')"
}

# Show help
_bwsh_help() {
    cat <<'EOF'
bwsh - Shell wrapper for Bitwarden Secrets Manager

USAGE:
  bwsh <command> [args]     Run as CLI
  source bwsh               Load functions into current shell

COMMANDS:
  get <name> [-p <project>]           Get a secret value
  set <name> [val] [-p <project>]     Create or update a secret
  list                                List all secret names
  delete <name>                       Delete a secret
  run [-p <project>] <cmd> [args...]  Run command with secrets as env vars
  env export                          Export secrets as .env format
  env import <file> [-p <project>]    Import secrets from .env file
  setup                               Interactive configuration
  update [--check]                    Update to latest version
  version                             Show version
  help                                Show this help

PROJECT RESOLUTION:
  Commands that need a project use this priority:
  1. Explicit -p/--project flag
  2. Default project from config (BWS_DEFAULT_PROJECT_ID)
  3. Interactive selection (prompts you to choose)

SHELL FUNCTIONS (when sourced):
  bwgetkey <name> [-p <project>]          Get a secret value
  bwkey <name> [val] [-p <project>]       Create or update a secret
  bwkeys                                  List all secret names
  bwdelkey <name>                         Delete a secret
  bwrun [-p <project>] <cmd> [args...]    Run command with secrets as env vars
  bwenv export|import                     Export/import .env files

ENVIRONMENT VARIABLES:
  BWS_ACCESS_TOKEN          Bitwarden Secrets Manager access token
  BWS_DEFAULT_PROJECT_ID    Default project ID for creating secrets
  BWSH_TOKEN_FILE           Token file path (default: ~/.config/bwsh/token)
  BWSH_PROJECT_FILE         Project file path (default: ~/.config/bwsh/project)

EXAMPLES:
  # CLI mode
  bwsh set API_KEY sk-abc123
  bwsh get API_KEY
  bwsh set DB_PASS secret -p abc123   # Use specific project
  bwsh get DB_PASS -p abc123
  bwsh list
  bwsh delete API_KEY
  bwsh run npm start                  # Run with secrets injected
  bwsh run -p abc123 npm start        # Run with specific project
  bwsh env export > .env              # Export to .env file
  bwsh env import .env                # Import from .env file
  bwsh env import .env -p abc123      # Import to specific project

  # Function mode (after sourcing)
  bwkey API_KEY sk-abc123
  bwgetkey API_KEY
  bwkey DB_PASS secret -p abc123      # Use specific project
  bwkeys
  bwdelkey API_KEY
  bwrun python app.py                 # Run with secrets injected
  bwrun -p abc123 python app.py       # Run with specific project
EOF
}

# CLI mode handler
_bwsh_cli() {
    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        get)
            bwgetkey "$@"
            ;;
        set)
            bwkey "$@"
            ;;
        list|ls)
            bwkeys
            ;;
        delete|rm)
            bwdelkey "$@"
            ;;
        run)
            bwrun "$@"
            ;;
        env)
            bwenv "$@"
            ;;
        setup)
            _bwsh_setup
            ;;
        update)
            _bwsh_update "$@"
            ;;
        version|-v|--version)
            echo "bwsh $BWSH_VERSION"
            ;;
        help|-h|--help)
            _bwsh_help
            ;;
        "")
            _bwsh_help
            ;;
        *)
            echo "Unknown command: $cmd" >&2
            echo "Run 'bwsh help' for usage" >&2
            return 1
            ;;
    esac
}

# Detect if script is being sourced or executed
# When sourced: just export functions (already defined above)
# When executed: run CLI handler
_bwsh_is_sourced() {
    if [[ -n "${ZSH_VERSION:-}" ]]; then
        # Zsh: $0 contains script path when executed, function name when sourced
        [[ "$ZSH_EVAL_CONTEXT" == *:file:* ]]
    elif [[ -n "${BASH_VERSION:-}" ]]; then
        # Bash: BASH_SOURCE[0] != $0 when sourced
        [[ "${BASH_SOURCE[0]}" != "$0" ]]
    else
        # Fallback: assume executed
        return 1
    fi
}

if ! _bwsh_is_sourced; then
    # Script is being executed directly - enable strict mode
    set -euo pipefail
    _bwsh_cli "$@"
fi
